1. Desarrollo de Diagrama de Flujo (L√≥gica de Suma de D√≠gitos)
El diagrama de flujo corresponde a la l√≥gica de Suma de D√≠gitos (implementada en el c√≥digo C):

Inicio

Inicializaci√≥n: suma = 0, temp_numero = abs(numero).

Bucle (WHILE): Mientras temp_numero > 0:

C√°lculo del D√≠gito: digito = temp_numero % 10 (resto).

Acumulaci√≥n: suma += digito.

Avance: temp_numero /= 10 (cociente).

Volver a la condici√≥n.

Fin: Mostrar suma.

2. Explicaci√≥n/Comentarios de Sentencias (Bucle de Divisi√≥n en Ensamblador)
MOV DX, 0: Inicializa DX a cero. Crucial antes de la divisi√≥n (DIV) para que el dividendo de 32 bits (DX:AX) sea solo el valor de AX.

DIV BX: Divide AX por 10 (divisor en BX). El Cociente (el nuevo n√∫mero) queda en AX, y el Resto (el d√≠gito) queda en DX.

ADD [SUMA_TOTAL], DX: Suma el d√≠gito (DX) al acumulador SUMA_TOTAL. Acumula el d√≠gito extra√≠do.

JNE SUMA_LOOP: Salta si el cociente en AX no es cero. Contin√∫a el ciclo hasta que el n√∫mero se haya dividido completamente.

5. Sentencias Usadas en Linux para Compilar y Linkear (Por Uziel)
Instalar nasm
sudo apt-get install nasm
Compilar para 32 bits

nasm -f elf32 factorial.asm -o factorial.o

Linkear

ld -m elf_i386 factorial.o -o factorial

Ejecutar

./factorial

Mis disculpas. Entiendo perfectamente: necesitas el texto organizado por los puntos de la actividad, sin ning√∫n formato de tabla, para copiar y pegar f√°cilmente.

Ajustar√© las separaciones y eliminar√© todos los s√≠mbolos que puedan interpretarse como tablas (como los dos puntos : y los pipes | de Markdown).

Aqu√≠ tienes el texto final, limpio y ordenado, listo para tu Google Colab:

üíª Actividad - Respuestas Organizadas para Colab
Materia: Arquitectura de Computadoras y Sistemas Operativos Fecha: 17 de Octubre de 2025 Nombres de integrantes: [Nombre del Integrante 1], [Nombre del Integrante 2], [Nombre del Integrante 3], ...

1. Desarrollo de Diagrama de Flujo (L√≥gica de Suma de D√≠gitos)
El diagrama de flujo corresponde a la l√≥gica de Suma de D√≠gitos (implementada en el c√≥digo C):

Inicio

Inicializaci√≥n: suma = 0, temp_numero = abs(numero).

Bucle (WHILE): Mientras temp_numero > 0:

C√°lculo del D√≠gito: digito = temp_numero % 10 (resto).

Acumulaci√≥n: suma += digito.

Avance: temp_numero /= 10 (cociente).

Volver a la condici√≥n.

Fin: Mostrar suma.

2. Explicaci√≥n/Comentarios de Sentencias (Bucle de Divisi√≥n en Ensamblador)
MOV DX, 0: Inicializa DX a cero. Crucial antes de la divisi√≥n (DIV) para que el dividendo de 32 bits (DX:AX) sea solo el valor de AX.

DIV BX: Divide AX por 10 (divisor en BX). El Cociente (el nuevo n√∫mero) queda en AX, y el Resto (el d√≠gito) queda en DX.

ADD [SUMA_TOTAL], DX: Suma el d√≠gito (DX) al acumulador SUMA_TOTAL. Acumula el d√≠gito extra√≠do.

JNE SUMA_LOOP: Salta si el cociente en AX no es cero. Contin√∫a el ciclo hasta que el n√∫mero se haya dividido completamente.

5. Sentencias Usadas en Linux para Compilar y Linkear (Por Uziel)
Instalar nasm

Bash

sudo apt-get install nasm
Compilar para 32 bits

Bash

nasm -f elf32 factorial.asm -o factorial.o
Linkear

Bash

ld -m elf_i386 factorial.o -o factorial
Ejecutar

Bash

./factorial
6. Investigar y Agregar Sentencias para Ingresar Valores por Teclado
El problema en Ensamblador es la Conversi√≥n de ASCII a valor num√©rico.

Problema (Tratamiento de ASCII): El n√∫mero ingresado se almacena como un c√≥digo ASCII (ej: '5' es 53), no como su valor num√©rico real (5).

Metodolog√≠a de Resoluci√≥n (Conversi√≥n Expl√≠cita): Se debe implementar la sentencia de conversi√≥n dentro del bucle de procesamiento de d√≠gitos:

Sentencia clave: SUB AL, '0' (o SUB AL, 48)

Funci√≥n: Restar el valor ASCII del car√°cter '0' al c√≥digo ASCII del d√≠gito, obteniendo su valor binario real.

7. Generar en Google Colab la misma versi√≥n en C
C√≥digo en C que resuelve la suma de los d√≠gitos de un n√∫mero entero:
%%writefile suma_digitos.c
#include <stdio.h>
#include <stdlib.h>

int main() {
¬† ¬† int numero;
¬† ¬† int suma = 0;
¬† ¬† int digito;

¬† ¬† printf("Ingrese un numero entero: ");

¬† ¬† if (scanf("%d", &numero) != 1) {
¬† ¬† ¬† ¬† printf("Error al leer el numero.\n");
¬† ¬† ¬† ¬† return 1;
¬† ¬† }

¬† ¬† int temp_numero = abs(numero);

¬† ¬† while (temp_numero > 0) {
¬† ¬† ¬† ¬† digito = temp_numero % 10;
¬† ¬† ¬† ¬† suma += digito;
¬† ¬† ¬† ¬† temp_numero /= 10;
¬† ¬† }

¬† ¬† printf("La suma de los digitos de %d es: %d\n", numero, suma);

¬† ¬† return 0;
}


8. Ejecutar y obtener el programa en lenguaje ensamblador del Item 7
Comandos usados:

!gcc suma_digitos.c -o suma_digitos
!./suma_digitos
!gcc -S suma_digitos.c
!cat suma_digitos.s


El c√≥digo ensamblador generado (suma_digitos.s) es el bloque de texto extenso que comienza con .file "suma_digitos.c".

9. Comparar las Versiones de Ensamblador
An√°lisis Comparativo:

El c√≥digo generado por GCC (suma_digitos.s) es un ejemplo de optimizaci√≥n de c√≥digo m√°quina (m√°s r√°pido), mientras que el c√≥digo Manual (mi_suma.asm) es un ejemplo de legibilidad y fidelidad a la l√≥gica algor√≠tmica.

Optimizaci√≥n: GCC evita la instrucci√≥n lenta DIV, usando secuencias de IMUL y shifts para mayor velocidad.

Legibilidad: El c√≥digo manual es m√°s legible. El c√≥digo de GCC es complejo, incluye llamadas a funciones de C y gesti√≥n avanzada de registros y pila.

10. Observar Situaciones Problem√°ticas e Identificar Metodolog√≠a de Resoluci√≥n
1. Conflicto en la Instrucci√≥n DIV: An√°lisis de la arquitectura: Implementar MOV DX, 0 antes de la divisi√≥n para asegurar el dividendo correcto de 32 bits.

2. Ingreso y Conversi√≥n de Datos: Conversi√≥n Expl√≠cita: Implementar SUB AL, '0' para convertir el c√≥digo ASCII del d√≠gito ingresado en su valor binario real.

3. Adaptaci√≥n de Plataforma: Investigaci√≥n de Documentaci√≥n (Syscalls): Reemplazar las interrupciones de DOS (INT 21H) con el uso de syscall para interactuar con Linux.

13. ¬øPor qu√© en el Ejercicio 3: Suma de Array con Direccionamiento Indexado, el ‚ÄúADD SI, 2‚Äù avanza de 2?
Respuesta a Pregunta Te√≥rica:

La instrucci√≥n ADD SI, 2 se usa para avanzar el puntero de √≠ndice (SI) en dos bytes porque los elementos del array fueron definidos con la directiva DW (Define Word).

En la arquitectura de 16 bits, una Word (Palabra) ocupa exactamente 2 bytes de memoria.

Para pasar al elemento siguiente en el array, el puntero debe saltar exactamente 2 bytes. El n√∫mero 2 coincide con el tama√±o en bytes del tipo de dato definido.
